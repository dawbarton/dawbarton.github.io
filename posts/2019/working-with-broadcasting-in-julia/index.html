<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Working with broadcasting in Julia | David AW Barton</title><meta name=keywords content="julia,open-source"><meta name=description content="Broadcasting in Julia is a way of writing vectorised code (think Matlab) that is performant and explicit. The benefits of performant code are obvious (faster!) but explicit vectorisation is also a significant benefit.
When I first saw Matlab and how you could call the sin with a vector input, I was (slightly) blown away by the usefulness of this. It didn&rsquo;t take too long for me to realise the limitations though; vectorising a complicated function can require quite a bit of code gymnastics, which doesn&rsquo;t usually help the readability, particularly for those students who are relatively new to programming."><meta name=author content><link rel=canonical href=https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://cityinthesky.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cityinthesky.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cityinthesky.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://cityinthesky.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://cityinthesky.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="Working with broadcasting in Julia"><meta property="og:description" content="Broadcasting in Julia is a way of writing vectorised code (think Matlab) that is performant and explicit. The benefits of performant code are obvious (faster!) but explicit vectorisation is also a significant benefit.
When I first saw Matlab and how you could call the sin with a vector input, I was (slightly) blown away by the usefulness of this. It didn&rsquo;t take too long for me to realise the limitations though; vectorising a complicated function can require quite a bit of code gymnastics, which doesn&rsquo;t usually help the readability, particularly for those students who are relatively new to programming."><meta property="og:type" content="article"><meta property="og:url" content="https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-16T00:00:00+00:00"><meta property="article:modified_time" content="2019-01-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Working with broadcasting in Julia"><meta name=twitter:description content="Broadcasting in Julia is a way of writing vectorised code (think Matlab) that is performant and explicit. The benefits of performant code are obvious (faster!) but explicit vectorisation is also a significant benefit.
When I first saw Matlab and how you could call the sin with a vector input, I was (slightly) blown away by the usefulness of this. It didn&rsquo;t take too long for me to realise the limitations though; vectorising a complicated function can require quite a bit of code gymnastics, which doesn&rsquo;t usually help the readability, particularly for those students who are relatively new to programming."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cityinthesky.co.uk/posts/"},{"@type":"ListItem","position":2,"name":"Working with broadcasting in Julia","item":"https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Working with broadcasting in Julia","name":"Working with broadcasting in Julia","description":"Broadcasting in Julia is a way of writing vectorised code (think Matlab) that is performant and explicit. The benefits of performant code are obvious (faster!) but explicit vectorisation is also a significant benefit.\nWhen I first saw Matlab and how you could call the sin with a vector input, I was (slightly) blown away by the usefulness of this. It didn\u0026rsquo;t take too long for me to realise the limitations though; vectorising a complicated function can require quite a bit of code gymnastics, which doesn\u0026rsquo;t usually help the readability, particularly for those students who are relatively new to programming.","keywords":["julia","open-source"],"articleBody":"Broadcasting in Julia is a way of writing vectorised code (think Matlab) that is performant and explicit. The benefits of performant code are obvious (faster!) but explicit vectorisation is also a significant benefit.\nWhen I first saw Matlab and how you could call the sin with a vector input, I was (slightly) blown away by the usefulness of this. It didn’t take too long for me to realise the limitations though; vectorising a complicated function can require quite a bit of code gymnastics, which doesn’t usually help the readability, particularly for those students who are relatively new to programming.\nThis is where Julia’s dot broadcasting (vectorisation) comes in. If you want a function to work on a vector of inputs (applying the same function to each element of the vector) you simply put a dot on the function call. For example, the sine of a vector of values becomes sin.([1.1, 0.3, 2.3]); note the extra dot between the sin and the first bracket.\nFor a really good introduction to this, see the blog post More Dots: Syntactic Loop Fusion in Julia.\nIn Julia v0.7/1.0, there were some changes under the hood to how broadcasting works. (See Extensible broadcast fusion for more details and how it can be customised by different types.) It now creates a series of Broadcasted objects that get fused together before finally being materialised to give the final answer. For example, consider\nr = sqrt(sum(x.^2 .+ y.^2)) Internally this gets rewritten (“lowered”) to\nr = sqrt(sum(materialize(broadcasted(+, broadcasted(^, x, 2), broadcasted(^, y, 2))))) (This isn’t quite accurate on the details since the squaring is implemented slightly differently.) Notice the hierarchy of broadcasted calls enclosed within a call to materialize. This is where the magic of broadcast fusion happens (and enables Julia to construct performant code). The broadcasted calls create a nested set of Broadcasted objects that contain the (lazily evaluated) vectorised expression and the materialize call creates the final vector from this.\nMost of the time this automatic magic is exactly what we want. But sometimes it’s not.\nConsider the case above where the sum is being computed; a vector will be allocated in memory for the calculation x.^2 + y.^2 and if x and y are large then a large amount of memory will be allocated unnecessarily for this intermediate value. Since the sum function doesn’t need all the values at the same time, couldn’t we just lazily compute x.^2 + y.^2 as individual numbers and feed them to the sum one-by-one? For example, we could do something like\nacc = 0.0 for i = eachindex(x, y) acc += x[i]^2 + y[i]^2 end r = sqrt(acc) In this case writing out the explicit for loop is something we’re trying to avoid (otherwise why bother with broadcasting?). Can we somehow extract the lazy representation from the broadcasting without materializing the intermediate result?\nThe answer is yes, but unfortunately it’s not part of the base Julia (yet). The code below gives us a lazy macro that enables us to get access to that lazy representation that broadcasting creates and use it explicitly in our surrounding code.\n@inline _lazy(x) = x[1] # unwrap the tuple @inline Broadcast.broadcasted(::typeof(_lazy), x) = (x,) # wrap the Broadcasted object in a tuple to avoid materializing macro lazy(x) return esc(:(_lazy(_lazy.($x)))) end Now we can compare the lazy version and the eager (materialized) versions.\njulia using BenchmarkTools julia x = rand(1_000_000) ; y = rand(1_000_000) ; julia @btime sqrt(sum(x.^2 .+ y.^2)) # normal eager evaluation 2.837 ms (16 allocations: 7.63 MiB) 816.7514405417339 julia @btime sqrt(sum(@lazy x.^2 .+ y.^2)) # lazy broadcasted evaluation 1.075 ms (12 allocations: 208 bytes) 816.7514405417412 Notice the memory consumption: 7.63 MiB for the normal version versus 208 bytes for the lazily evaluated version. Similarly the lazy version is significantly faster (though that depends quite a lot on the size of the vectors used). There is a slightly different answer in the two cases since the Julia sum function uses slightly different algorithms for vectors versus iterators (so I’m not quite comparing like-for-like).\nWhy is the lazy version not the default? Well here is the caveat: as soon as you do lazy evaluation the performance becomes much more problem dependent - it can get faster (as in this case) but, equally, it can get slower. BenchmarkTools.jl is your friend!\n","wordCount":"716","inLanguage":"en","datePublished":"2019-01-16T00:00:00Z","dateModified":"2019-01-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/"},"publisher":{"@type":"Organization","name":"David AW Barton","logo":{"@type":"ImageObject","url":"https://cityinthesky.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://cityinthesky.co.uk/ accesskey=h title="David AW Barton (Alt + H)">David AW Barton</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://cityinthesky.co.uk/about-me/ title="About me"><span>About me</span></a></li><li><a href=https://cityinthesky.co.uk/research/ title=Research><span>Research</span></a></li><li><a href=https://cityinthesky.co.uk/opensource/ title="Open source"><span>Open source</span></a></li><li><a href=https://cityinthesky.co.uk/christianity/ title=Christianity><span>Christianity</span></a></li><li><a href=https://cityinthesky.co.uk/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cityinthesky.co.uk/>Home</a>&nbsp;»&nbsp;<a href=https://cityinthesky.co.uk/posts/>Posts</a></div><h1 class=post-title>Working with broadcasting in Julia</h1><div class=post-meta>2019-01-16</div></header><div class=post-content><p>Broadcasting in Julia is a way of writing vectorised code (think Matlab) that is performant and explicit. The benefits of performant code are obvious (faster!) but explicit vectorisation is also a significant benefit.</p><p>When I first saw Matlab and how you could call the <code>sin</code> with a vector input, I was (slightly) blown away by the usefulness of this. It didn&rsquo;t take too long for me to realise the limitations though; vectorising a complicated function can require quite a bit of code gymnastics, which doesn&rsquo;t usually help the readability, particularly for those students who are relatively new to programming.</p><p>This is where Julia&rsquo;s dot broadcasting (vectorisation) comes in. If you want a function to work on a vector of inputs (applying the same function to each element of the vector) you simply put a dot on the function call. For example, the sine of a vector of values becomes <code>sin.([1.1, 0.3, 2.3])</code>; note the extra dot between the sin and the first bracket.</p><p>For a really good introduction to this, see the blog post <a href=https://julialang.org/blog/2017/01/moredots>More Dots: Syntactic Loop Fusion in Julia.</a></p><p>In Julia v0.7/1.0, there were some changes under the hood to how broadcasting works. (See <a href=https://julialang.org/blog/2018/05/extensible-broadcast-fusion>Extensible broadcast fusion</a> for more details and how it can be customised by different types.) It now creates a series of <code>Broadcasted</code> objects that get fused together before finally being materialised to give the final answer. For example, consider</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia>r <span style=color:#f92672>=</span> sqrt(sum(x<span style=color:#f92672>.^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>.+</span> y<span style=color:#f92672>.^</span><span style=color:#ae81ff>2</span>))
</code></pre></div><p>Internally this gets rewritten (&ldquo;lowered&rdquo;) to</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia>r <span style=color:#f92672>=</span> sqrt(sum(materialize(broadcasted(<span style=color:#f92672>+</span>, broadcasted(<span style=color:#f92672>^</span>, x, <span style=color:#ae81ff>2</span>), broadcasted(<span style=color:#f92672>^</span>, y, <span style=color:#ae81ff>2</span>)))))
</code></pre></div><p>(This isn&rsquo;t quite accurate on the details since the squaring is implemented slightly differently.) Notice the hierarchy of <code>broadcasted</code> calls enclosed within a call to <code>materialize</code>. This is where the magic of broadcast fusion happens (and enables Julia to construct performant code). The <code>broadcasted</code> calls create a nested set of <code>Broadcasted</code> objects that contain the (lazily evaluated) vectorised expression and the <code>materialize</code> call creates the final vector from this.</p><p>Most of the time this automatic magic is exactly what we want. But sometimes it&rsquo;s not.</p><p>Consider the case above where the sum is being computed; a vector will be allocated in memory for the calculation <code>x.^2 + y.^2</code> and if <code>x</code> and <code>y</code> are large then a large amount of memory will be allocated unnecessarily for this intermediate value. Since the sum function doesn&rsquo;t need all the values at the same time, couldn&rsquo;t we just lazily compute <code>x.^2 + y.^2</code> as individual numbers and feed them to the sum one-by-one? For example, we could do something like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia>acc <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
<span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> eachindex(x, y)
    acc <span style=color:#f92672>+=</span> x[i]<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> y[i]<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>
<span style=color:#66d9ef>end</span>
r <span style=color:#f92672>=</span> sqrt(acc)
</code></pre></div><p>In this case writing out the explicit for loop is something we&rsquo;re trying to avoid (otherwise why bother with broadcasting?). Can we somehow extract the lazy representation from the broadcasting without materializing the intermediate result?</p><p>The answer is yes, but unfortunately it&rsquo;s not part of the base Julia (yet). The code below gives us a lazy macro that enables us to get access to that lazy representation that broadcasting creates and use it explicitly in our surrounding code.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=color:#a6e22e>@inline</span> _lazy(x) <span style=color:#f92672>=</span> x[<span style=color:#ae81ff>1</span>]  <span style=color:#75715e># unwrap the tuple</span>
<span style=color:#a6e22e>@inline</span> Broadcast<span style=color:#f92672>.</span>broadcasted(<span style=color:#f92672>::</span>typeof(_lazy), x) <span style=color:#f92672>=</span> (x,)  <span style=color:#75715e># wrap the Broadcasted object in a tuple to avoid materializing</span>
<span style=color:#66d9ef>macro</span> lazy(x)
    <span style=color:#66d9ef>return</span> esc(<span style=color:#f92672>:</span>(_lazy(_lazy<span style=color:#f92672>.</span>(<span style=color:#f92672>$</span>x))))
<span style=color:#66d9ef>end</span>
</code></pre></div><p>Now we can compare the lazy version and the eager (materialized) versions.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia>julia<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>using</span> BenchmarkTools

julia<span style=color:#f92672>&gt;</span> x <span style=color:#f92672>=</span> rand(<span style=color:#ae81ff>1_000_000</span>) ; y <span style=color:#f92672>=</span> rand(<span style=color:#ae81ff>1_000_000</span>) ;

julia<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>@btime</span> sqrt(sum(x<span style=color:#f92672>.^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>.+</span> y<span style=color:#f92672>.^</span><span style=color:#ae81ff>2</span>))  <span style=color:#75715e># normal eager evaluation</span>
  <span style=color:#ae81ff>2.837</span> ms (<span style=color:#ae81ff>16</span> allocations<span style=color:#f92672>:</span> <span style=color:#ae81ff>7.63</span> MiB)
<span style=color:#ae81ff>816.7514405417339</span>

julia<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>@btime</span> sqrt(sum(<span style=color:#a6e22e>@lazy</span> x<span style=color:#f92672>.^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>.+</span> y<span style=color:#f92672>.^</span><span style=color:#ae81ff>2</span>))  <span style=color:#75715e># lazy broadcasted evaluation</span>
  <span style=color:#ae81ff>1.075</span> ms (<span style=color:#ae81ff>12</span> allocations<span style=color:#f92672>:</span> <span style=color:#ae81ff>208</span> bytes)
<span style=color:#ae81ff>816.7514405417412</span>
</code></pre></div><p>Notice the memory consumption: 7.63 MiB for the normal version versus 208 bytes for the lazily evaluated version. Similarly the lazy version is significantly faster (though that depends quite a lot on the size of the vectors used). There is a slightly different answer in the two cases since the Julia <code>sum</code> function uses slightly different algorithms for vectors versus iterators (so I&rsquo;m not quite comparing like-for-like).</p><p>Why is the lazy version not the default? Well here is the caveat: as soon as you do lazy evaluation the performance becomes much more problem dependent - it can get faster (as in this case) but, equally, it can get slower. <a href=https://github.com/JuliaCI/BenchmarkTools.jl>BenchmarkTools.jl</a> is your friend!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cityinthesky.co.uk/tags/julia/>julia</a></li><li><a href=https://cityinthesky.co.uk/tags/open-source/>open-source</a></li></ul><nav class=paginav><a class=prev href=https://cityinthesky.co.uk/posts/2020/collocation-for-finding-periodic-orbits-of-odes/><span class=title>« Prev Page</span><br><span>Collocation for finding periodic orbits of ODEs</span></a>
<a class=next href=https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/><span class=title>Next Page »</span><br><span>BarycentricInterpolation.jl</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://cityinthesky.co.uk/>David AW Barton</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>