<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>BarycentricInterpolation.jl | David A W Barton</title>
<meta name=keywords content="julia,open-source"><meta name=description content="Over the past couple of years or so I&rsquo;ve been getting into the Julia programming language; it&rsquo;s been great to watch the language mature over time. Many people proclaim the virtues of its speed (it&rsquo;s very fast for a dynamic language) but really I like its elegance - it&rsquo;s a very well designed language that makes full use of multiple dispatch. (Multiple dispatch is something that I doubt most coders know much about but once you are used to it, it&rsquo;s indispensable!"><meta name=author content><link rel=canonical href=https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://cityinthesky.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cityinthesky.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cityinthesky.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://cityinthesky.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://cityinthesky.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css integrity=sha384-0cCFrwW/0bAk1Z/6IMgIyNU3kfTcNirlObr4WjrUU7+hZeD6ravdYJ3kPWSeC31M crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.js integrity=sha384-dtFDxK2tSkECx/6302Z4VN2ZRqt6Gis+b1IwCjJPrn0kMYFQT9rbtyQWg5NFWAF7 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="BarycentricInterpolation.jl"><meta property="og:description" content="Over the past couple of years or so I&rsquo;ve been getting into the Julia programming language; it&rsquo;s been great to watch the language mature over time. Many people proclaim the virtues of its speed (it&rsquo;s very fast for a dynamic language) but really I like its elegance - it&rsquo;s a very well designed language that makes full use of multiple dispatch. (Multiple dispatch is something that I doubt most coders know much about but once you are used to it, it&rsquo;s indispensable!"><meta property="og:type" content="article"><meta property="og:url" content="https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-12-04T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="BarycentricInterpolation.jl"><meta name=twitter:description content="Over the past couple of years or so I&rsquo;ve been getting into the Julia programming language; it&rsquo;s been great to watch the language mature over time. Many people proclaim the virtues of its speed (it&rsquo;s very fast for a dynamic language) but really I like its elegance - it&rsquo;s a very well designed language that makes full use of multiple dispatch. (Multiple dispatch is something that I doubt most coders know much about but once you are used to it, it&rsquo;s indispensable!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cityinthesky.co.uk/posts/"},{"@type":"ListItem","position":2,"name":"BarycentricInterpolation.jl","item":"https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BarycentricInterpolation.jl","name":"BarycentricInterpolation.jl","description":"Over the past couple of years or so I\u0026rsquo;ve been getting into the Julia programming language; it\u0026rsquo;s been great to watch the language mature over time. Many people proclaim the virtues of its speed (it\u0026rsquo;s very fast for a dynamic language) but really I like its elegance - it\u0026rsquo;s a very well designed language that makes full use of multiple dispatch. (Multiple dispatch is something that I doubt most coders know much about but once you are used to it, it\u0026rsquo;s indispensable!","keywords":["julia","open-source"],"articleBody":"Over the past couple of years or so I’ve been getting into the Julia programming language; it’s been great to watch the language mature over time. Many people proclaim the virtues of its speed (it’s very fast for a dynamic language) but really I like its elegance - it’s a very well designed language that makes full use of multiple dispatch. (Multiple dispatch is something that I doubt most coders know much about but once you are used to it, it’s indispensable!)\nMy first foray into the world of Julia package development is BarycentricInterpolation.jl, a small package to do polynomial interpolation using a Barycentric representation. This approach is espoused in Berrut and Trefethen, SIAM Review 2004 as a way to do polynomial interpolation with O(n) operations, rather than O(n2) operations as is more typical for interpolation with Lagrange polynomials.\nWhile this package isn’t really a general purpose interpolation code (see Interpolations.jl for that), it is good for building numerical algorithms such as collocation.\nOne example of this is a simple(ish) simulation of a dynamic cantilever beam. The Euler-Bernoulli equation is the most straightforward, non-trivial model we can use -\n$$ \\frac{EI}{\\rho AL^4}\\frac{\\partial^4u}{\\partial x^4} + \\frac{\\partial^2 u}{\\partial t^2} + \\xi\\frac{\\partial u}{\\partial t} = 0 $$\nwhere $E$ is Young’s modulus, $I$ is the second moment of area, $\\rho A$ is the mass per unit length, $L$ is the length, and $\\xi$ is the (external) damping coefficient.\nSince it is a fourth-order partial differential equation in space we need four boundary conditions. For a cantilever beam we have (primes denote derivatives with respect to $x$)\n$u(0, t) = 0$ (zero displacement at wall)\n$u’(0,t) = 0$ (zero slope at wall)\n$u’’(1,t) = 0$ (zero torque at free end)\n$u’’’(1,t) = 0$ (zero shear at free end)\nTo solve the Euler-Bernoulli equation we discretise the model in space using Chebyshev polynomials (for an introduction to Chebyshev approximations to differential equations see the excellent, and relatively short, book Spectral Methods in Matlab by Nick Trefethen). This is where BarycentricInterpolation.jl comes in.\nIn a nutshell, we’re going to use an $N$ degree polynomial to approximate the solution in the $x$ direction by constraining the polynomial to satisfy the four boundary conditions at $x=0$ and $x=1$ and then evaluating the fourth derivative for the interior of the Euler-Bernoulli equation.\nI’m going to arbitrarily choose to evaluate the Euler-Bernoulli equation at the Chebyshev nodes of the $N-2$ degree Chebyshev polynomial, excluding the end points, so $N-3$ points in total. Hence these points plus the four boundary conditions gives $N+1$ equations to match the $N+1$ unknowns of the $N$ degree Chebyshev polynomial.\nThe code to do this is as follows. The end result is a fourth-order derivative matrix defined on the collocation points.\nusing BarycentricInterpolation N = 10 # degree of the polynomial n = N-2 # Construct the polynomial P = Chebyshev2{N}() # Generate the differentiation matrix y' ≈ Dy D = differentiation_matrix(P) # Collocation points (nodes of the N-2 degree second-kind Chebyshev polynomial) x_coll = [-cospi(j/n) for j = 1:n-1] # Interpolation matrix from nodes(P) to x_coll In = interpolation_matrix(P, x_coll) # Construct the mapping from the values at the collocation points to the # values at the nodes of the Chebyshev polynomial, simultaneously # incorporating the boundary conditions In⁻¹ = inv([In; # interpolation to collocation points [1 zeros(1, N)]; # u(0, t) = 0 D[1:1, :]; # u'(0, t) = 0 (D^2)[end:end, :] # u''(1, t) = 0 (D^3)[end:end, :] # u'''(1, t) = 0 ])[:, 1:end-4] # remove the boundary condition inputs since they are zero # Construct the differentiation matrix that incorporates the boundary conditions D₄ = In*(D^4)*In⁻¹ The basic premise is to construct a fourth-order differentiation matrix on the $N$-degree Chebyshev polynomial whilst incorporating the boundary conditions. This is done by mapping from the collocation points onto the nodes of the Chebyshev polynomial, incorporating the boundary conditions, then applying the differentiation matrix before mapping back to the collocation points.\nTo integrate the equations of motion, the second-order (in time) differential equation is rewritten as a system of first-order ODEs and thrown into DifferentialEquations.jl.\nfunction beammodel!(dudt, u, p, t) n = size(p.D₄, 2) # number of collocation points dudt[1:n] .= u[n+1:2n] # u̇₁ = u₂ dudt[n+1:2n] .= -p.EI/p.ρA*(p.D₄*u[1:n]) .- p.ξ*u[n+1:2n] # u̇₂ = -EI/ρA*u₁'''' - ξ*u₂ end Before integrating, we need some initial conditions. To avoid putting energy into the higher modes of the beam, I use the mode shape of the first beam mode for the initial conditions.\n# A parameter vector for integration; a steel beam (1m × 10mm × 1mm) p = (D₄ = D₄, EI = 1666.6, ρA = 8.0, ξ = 0.2) # Jacobian matrix of the differential equation using LinearAlgebra A = [zeros(size(p.D₄)) I; -p.EI/p.ρA*p.D₄ -p.ξ*I] ev = eigen(A) idx = argmin(abs.(ev.values)) # lowest mode u0 = real.(ev.vectors[:, idx]) # ignore rotations # Integrate! using OrdinaryDiffEq prob = ODEProblem(beammodel!, u0, (0, 10.0), p) sol = solve(prob, Rodas5(), dtmax=0.05) # use a stiff solver And to plot\nusing Makie sc = Scene() wf = wireframe!(sc, x_coll, sol.t, sol[1:N-3, :]) scale!(wf, 1.0, 1.0, 10.0) l = lines!(sc, [x_coll[end]], sol.t, sol[N-3, :], color=:red, linewidth=3.0) The result is at the top of this post!\nWhile this is a largely academic example (we could solve this problem analytically) there are lots of extensions that can be made with this approach.\n","wordCount":"888","inLanguage":"en","datePublished":"2018-12-04T00:00:00Z","dateModified":"2018-12-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/"},"publisher":{"@type":"Organization","name":"David A W Barton","logo":{"@type":"ImageObject","url":"https://cityinthesky.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cityinthesky.co.uk/ accesskey=h title="David A W Barton (Alt + H)">David A W Barton</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://cityinthesky.co.uk/about-me/ title=About><span>About</span></a></li><li><a href=https://cityinthesky.co.uk/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://cityinthesky.co.uk/research/ title=Research><span>Research</span></a></li><li><a href=https://cityinthesky.co.uk/opensource/ title="Open source"><span>Open source</span></a></li><li><a href=https://cityinthesky.co.uk/christianity/ title=Christianity><span>Christianity</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cityinthesky.co.uk/>Home</a>&nbsp;»&nbsp;<a href=https://cityinthesky.co.uk/posts/>Posts</a></div><h1 class=post-title>BarycentricInterpolation.jl</h1><div class=post-meta><span title='2018-12-04 00:00:00 +0000 UTC'>2018-12-04</span></div></header><div class=post-content><p>Over the past couple of years or so I&rsquo;ve been getting into the Julia programming language; it&rsquo;s been great to watch the language mature over time. Many people proclaim the virtues of its speed (it&rsquo;s very fast for a dynamic language) but really I like its elegance - it&rsquo;s a very well designed language that makes full use of multiple dispatch. (Multiple dispatch is something that I doubt most coders know much about but once you are used to it, it&rsquo;s indispensable!)</p><p>My first foray into the world of Julia package development is <a href=https://github.com/dawbarton/BarycentricInterpolation.jl>BarycentricInterpolation.jl</a>, a small package to do polynomial interpolation using a Barycentric representation. This approach is espoused in <a href=https://people.maths.ox.ac.uk/trefethen/barycentric.pdf>Berrut and Trefethen, SIAM Review 2004</a> as a way to do polynomial interpolation with O(n) operations, rather than O(n2) operations as is more typical for interpolation with Lagrange polynomials.</p><p>While this package isn&rsquo;t really a general purpose interpolation code (see <a href=https://github.com/JuliaMath/Interpolations.jl>Interpolations.jl</a> for that), it is good for building numerical algorithms such as collocation.</p><p>One example of this is a simple(ish) simulation of a dynamic cantilever beam. The <a href=https://en.wikipedia.org/wiki/Euler%E2%80%93Bernoulli_beam_theory>Euler-Bernoulli equation</a> is the most straightforward, non-trivial model we can use -</p><p>$$ \frac{EI}{\rho AL^4}\frac{\partial^4u}{\partial x^4} + \frac{\partial^2 u}{\partial t^2} + \xi\frac{\partial u}{\partial t} = 0 $$</p><p>where $E$ is Young&rsquo;s modulus, $I$ is the second moment of area, $\rho A$ is the mass per unit length, $L$ is the length, and $\xi$ is the (external) damping coefficient.</p><p>Since it is a fourth-order partial differential equation in space we need four boundary conditions. For a cantilever beam we have (primes denote derivatives with respect to $x$)</p><p>$u(0, t) = 0$ (zero displacement at wall)</p><p>$u&rsquo;(0,t) = 0$ (zero slope at wall)</p><p>$u&rsquo;&rsquo;(1,t) = 0$ (zero torque at free end)</p><p>$u&rsquo;&rsquo;&rsquo;(1,t) = 0$ (zero shear at free end)</p><p>To solve the Euler-Bernoulli equation we discretise the model in space using Chebyshev polynomials (for an introduction to Chebyshev approximations to differential equations see the excellent, and relatively short, book Spectral Methods in Matlab by Nick Trefethen). This is where BarycentricInterpolation.jl comes in.</p><p>In a nutshell, we&rsquo;re going to use an $N$ degree polynomial to approximate the solution in the $x$ direction by constraining the polynomial to satisfy the four boundary conditions at $x=0$ and $x=1$ and then evaluating the fourth derivative for the interior of the Euler-Bernoulli equation.</p><p>I&rsquo;m going to arbitrarily choose to evaluate the Euler-Bernoulli equation at the Chebyshev nodes of the $N-2$ degree Chebyshev polynomial, excluding the end points, so $N-3$ points in total. Hence these points plus the four boundary conditions gives $N+1$ equations to match the $N+1$ unknowns of the $N$ degree Chebyshev polynomial.</p><p>The code to do this is as follows. The end result is a fourth-order derivative matrix defined on the collocation points.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>using</span> BarycentricInterpolation
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>  <span style=color:#75715e># degree of the polynomial</span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> N<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>  
</span></span><span style=display:flex><span><span style=color:#75715e># Construct the polynomial</span>
</span></span><span style=display:flex><span>P <span style=color:#f92672>=</span> <span style=color:#66d9ef>Chebyshev2</span>{<span style=color:#66d9ef>N</span>}()
</span></span><span style=display:flex><span><span style=color:#75715e># Generate the differentiation matrix y&#39; ≈ Dy</span>
</span></span><span style=display:flex><span>D <span style=color:#f92672>=</span> differentiation_matrix(P)
</span></span><span style=display:flex><span><span style=color:#75715e># Collocation points (nodes of the N-2 degree second-kind Chebyshev polynomial)</span>
</span></span><span style=display:flex><span>x_coll <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span>cospi(j<span style=color:#f92672>/</span>n) <span style=color:#66d9ef>for</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span><span style=color:#75715e># Interpolation matrix from nodes(P) to x_coll</span>
</span></span><span style=display:flex><span>In <span style=color:#f92672>=</span> interpolation_matrix(P, x_coll)  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Construct the mapping from the values at the collocation points to the</span>
</span></span><span style=display:flex><span><span style=color:#75715e># values at the nodes of the Chebyshev polynomial, simultaneously</span>
</span></span><span style=display:flex><span><span style=color:#75715e># incorporating the  boundary conditions</span>
</span></span><span style=display:flex><span>In⁻¹ <span style=color:#f92672>=</span> inv([In;                           <span style=color:#75715e># interpolation to collocation points</span>
</span></span><span style=display:flex><span>            [<span style=color:#ae81ff>1</span> zeros(<span style=color:#ae81ff>1</span>, N)];              <span style=color:#75715e># u(0, t) = 0</span>
</span></span><span style=display:flex><span>            D[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>:</span>];                    <span style=color:#75715e># u&#39;(0, t) = 0</span>
</span></span><span style=display:flex><span>            (D<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>)[end<span style=color:#f92672>:</span>end, <span style=color:#f92672>:</span>]             <span style=color:#75715e># u&#39;&#39;(1, t) = 0</span>
</span></span><span style=display:flex><span>            (D<span style=color:#f92672>^</span><span style=color:#ae81ff>3</span>)[end<span style=color:#f92672>:</span>end, <span style=color:#f92672>:</span>]             <span style=color:#75715e># u&#39;&#39;&#39;(1, t) = 0</span>
</span></span><span style=display:flex><span>           ])[<span style=color:#f92672>:</span>, <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#66d9ef>end</span><span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>]  <span style=color:#75715e># remove the boundary condition inputs since they are zero</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Construct the differentiation matrix that incorporates the boundary conditions</span>
</span></span><span style=display:flex><span>D₄ <span style=color:#f92672>=</span> In<span style=color:#f92672>*</span>(D<span style=color:#f92672>^</span><span style=color:#ae81ff>4</span>)<span style=color:#f92672>*</span>In⁻¹
</span></span></code></pre></div><p>The basic premise is to construct a fourth-order differentiation matrix on the $N$-degree Chebyshev polynomial whilst incorporating the boundary conditions. This is done by mapping from the collocation points onto the nodes of the Chebyshev polynomial, incorporating the boundary conditions, then applying the differentiation matrix before mapping back to the collocation points.</p><p>To integrate the equations of motion, the second-order (in time) differential equation is rewritten as a system of first-order ODEs and thrown into <a href=https://diffeq.sciml.ai/latest/>DifferentialEquations.jl</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>function</span> beammodel!(dudt, u, p, t)
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> size(p<span style=color:#f92672>.</span>D₄, <span style=color:#ae81ff>2</span>)  <span style=color:#75715e># number of collocation points</span>
</span></span><span style=display:flex><span>    dudt[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n] <span style=color:#f92672>.=</span> u[n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span>n]  <span style=color:#75715e># u̇₁ = u₂</span>
</span></span><span style=display:flex><span>    dudt[n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span>n] <span style=color:#f92672>.=</span> <span style=color:#f92672>-</span>p<span style=color:#f92672>.</span>EI<span style=color:#f92672>/</span>p<span style=color:#f92672>.</span>ρA<span style=color:#f92672>*</span>(p<span style=color:#f92672>.</span>D₄<span style=color:#f92672>*</span>u[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>n]) <span style=color:#f92672>.-</span> p<span style=color:#f92672>.</span>ξ<span style=color:#f92672>*</span>u[n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span>n]  <span style=color:#75715e># u̇₂ = -EI/ρA*u₁&#39;&#39;&#39;&#39; - ξ*u₂</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Before integrating, we need some initial conditions. To avoid putting energy into the higher modes of the beam, I use the mode shape of the first beam mode for the initial conditions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#75715e># A parameter vector for integration; a steel beam (1m × 10mm × 1mm)</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> (D₄ <span style=color:#f92672>=</span> D₄, EI <span style=color:#f92672>=</span> <span style=color:#ae81ff>1666.6</span>, ρA <span style=color:#f92672>=</span> <span style=color:#ae81ff>8.0</span>, ξ <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Jacobian matrix of the differential equation</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> LinearAlgebra
</span></span><span style=display:flex><span>A <span style=color:#f92672>=</span> [zeros(size(p<span style=color:#f92672>.</span>D₄)) I; <span style=color:#f92672>-</span>p<span style=color:#f92672>.</span>EI<span style=color:#f92672>/</span>p<span style=color:#f92672>.</span>ρA<span style=color:#f92672>*</span>p<span style=color:#f92672>.</span>D₄ <span style=color:#f92672>-</span>p<span style=color:#f92672>.</span>ξ<span style=color:#f92672>*</span>I]
</span></span><span style=display:flex><span>ev <span style=color:#f92672>=</span> eigen(A)
</span></span><span style=display:flex><span>idx <span style=color:#f92672>=</span> argmin(abs<span style=color:#f92672>.</span>(ev<span style=color:#f92672>.</span>values))  <span style=color:#75715e># lowest mode</span>
</span></span><span style=display:flex><span>u0 <span style=color:#f92672>=</span> real<span style=color:#f92672>.</span>(ev<span style=color:#f92672>.</span>vectors[<span style=color:#f92672>:</span>, idx])  <span style=color:#75715e># ignore rotations</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Integrate!</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> OrdinaryDiffEq
</span></span><span style=display:flex><span>prob <span style=color:#f92672>=</span> ODEProblem(beammodel!, u0, (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10.0</span>), p)
</span></span><span style=display:flex><span>sol <span style=color:#f92672>=</span> solve(prob, Rodas5(), dtmax<span style=color:#f92672>=</span><span style=color:#ae81ff>0.05</span>)  <span style=color:#75715e># use a stiff solver</span>
</span></span></code></pre></div><p>And to plot</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>using</span> Makie
</span></span><span style=display:flex><span>sc <span style=color:#f92672>=</span> Scene()
</span></span><span style=display:flex><span>wf <span style=color:#f92672>=</span> wireframe!(sc, x_coll, sol<span style=color:#f92672>.</span>t, sol[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>, <span style=color:#f92672>:</span>])
</span></span><span style=display:flex><span>scale!(wf, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>10.0</span>)
</span></span><span style=display:flex><span>l <span style=color:#f92672>=</span> lines!(sc, [x_coll[<span style=color:#66d9ef>end</span>]], sol<span style=color:#f92672>.</span>t, sol[N<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>, <span style=color:#f92672>:</span>], color<span style=color:#f92672>=</span><span style=color:#e6db74>:red</span>, linewidth<span style=color:#f92672>=</span><span style=color:#ae81ff>3.0</span>)
</span></span></code></pre></div><p>The result is at the top of this post!</p><p>While this is a largely academic example (we could solve this problem analytically) there are lots of extensions that can be made with this approach.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cityinthesky.co.uk/tags/julia/>Julia</a></li><li><a href=https://cityinthesky.co.uk/tags/open-source/>Open-Source</a></li></ul><nav class=paginav><a class=prev href=https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/><span class=title>« Prev</span><br><span>Working with broadcasting in Julia</span>
</a><a class=next href=https://cityinthesky.co.uk/posts/2023/project-active-learning-for-nonlinear-nodes/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://cityinthesky.co.uk/>David A W Barton</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>