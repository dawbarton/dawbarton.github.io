<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Collocation for finding periodic orbits of ODEs | David AW Barton</title><meta name=keywords content="julia,mathematics"><meta name=description content="Computing periodic orbits of ordinary differential equations (ODEs) with collocation is a relatively quick and easy thing to do. Here I demonstrate the method using both Julia and MATLAB with Fourier collocation."><meta name=author content><link rel=canonical href=https://cityinthesky.co.uk/posts/2020/collocation-for-finding-periodic-orbits-of-odes/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://cityinthesky.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cityinthesky.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cityinthesky.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://cityinthesky.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://cityinthesky.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Collocation for finding periodic orbits of ODEs"><meta property="og:description" content="Computing periodic orbits of ordinary differential equations (ODEs) with collocation is a relatively quick and easy thing to do. Here I demonstrate the method using both Julia and MATLAB with Fourier collocation."><meta property="og:type" content="article"><meta property="og:url" content="https://cityinthesky.co.uk/posts/2020/collocation-for-finding-periodic-orbits-of-odes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-05-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Collocation for finding periodic orbits of ODEs"><meta name=twitter:description content="Computing periodic orbits of ordinary differential equations (ODEs) with collocation is a relatively quick and easy thing to do. Here I demonstrate the method using both Julia and MATLAB with Fourier collocation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cityinthesky.co.uk/posts/"},{"@type":"ListItem","position":2,"name":"Collocation for finding periodic orbits of ODEs","item":"https://cityinthesky.co.uk/posts/2020/collocation-for-finding-periodic-orbits-of-odes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Collocation for finding periodic orbits of ODEs","name":"Collocation for finding periodic orbits of ODEs","description":"Computing periodic orbits of ordinary differential equations (ODEs) with collocation is a relatively quick and easy thing to do. Here I demonstrate the method using both Julia and MATLAB with Fourier collocation.","keywords":["julia","mathematics"],"articleBody":"Every now and again I’m asked how to compute the periodic orbits of ODEs using a boundary value solver. Each time, I go looking for old code that does this and, each time, I can’t find it and end up rewriting the collocation code from scratch.\nThis time I thought I’d put my code here so that I have a better chance of finding it again in the future!\nThe basic idea is to use a Fourier differentiation matrix to approximate the derivatives along the orbit and use a nonlinear solver to ensure that those derivatives match the vector field. If you want to know more about these types of spectral methods, take a look at the excellent (and short!) introduction by Trefethen in “Spectral Methods in MATLAB”, SIAM 2000. If you want more detail then the magnum opus by Boyd “Chebyshev and Fourier Spectral Methods”, Dover 2001 (freely available on his personal website) is also very good.\nNowadays, my preference is for coding in Julia - it’s very clean and flexible. Here is the code (which could be better!).\n# Released under the MIT expat license by David A.W. Barton (david.barton@bristol.ac.uk) 2020 using StaticArrays using NLsolve using OrdinaryDiffEq \"\"\" duffing(u, p, t) The vector field of the forced Duffing equation. \"\"\" duffing(u, p, t) = SVector(u[2], p.Γ*sin(p.ω*t) - 2p.ξ*u[2] - p.ωₙ^2*u[1] - p.β*u[1]^3) \"\"\" fourier_diff([T=Float64,] N; order=1) Create a Fourier differentiation matrix of the specified order with numerical type T on the domain `x = LinRange{T}(0, 2π, N+1)[1:end-1]`. \"\"\" function fourier_diff(T::Type{\u003c:Number}, N::Integer; order=1) D = zeros(T, N, N) n1 = (N - 1) ÷ 2 n2 = N ÷ 2 x = LinRange{T}(0, π, N+1) if order == 1 for i in 2:N sgn = (one(T)/2 - iseven(i)) D[i, 1] = iseven(N) ? sgn*cot(x[i]) : sgn*csc(x[i]) end elseif order == 2 D[1, 1] = iseven(N) ? -N^2*one(T)/12 - one(T)/6 : -N^2*one(T)/12 + one(T)/12 for i in 2:N sgn = -(one(T)/2 - iseven(i)) D[i, 1] = iseven(N) ? sgn*csc(x[i]).^2 : sgn*cot(x[i])*csc(x[i]) end else error(\"Not implemented\") end for j in 2:N D[1, j] = D[N, j-1] D[2:N, j] .= D[1:N-1, j-1] end return D end fourier_diff(N::Integer; kwargs...) = fourier_diff(Float64, N; kwargs...) \"\"\" collocation_setup(u) Return a data structure used internally by the `collocation!` function. `u` should be a matrix with states down the columns and time across the rows (used for size/type information only). \"\"\" function collocation_setup(u::AbstractMatrix) return (ndim=size(u, 1), nmesh=size(u, 2), Dt=-fourier_diff(eltype(u), size(u, 2))*2π) end \"\"\" collocation!(res, f, u, p, T, coll) Calculate the residual of the collocation equations using a Fourier discretisation. Assumes that a phase condition is not required (i.e., the equations are non-autonomous or the period is known). # Arguments - `res`: residual (mutated) - `f`: vector field function (expected to take the arguments (u, p, t)) - `u`: state variables along the orbit (vector) - `p`: parameter vector passed to the vector field function - `T`: period of oscillation - `coll`: the output of `collocation_setup` # Returns - `res`: residual \"\"\" function collocation!(res, f, u, p, T, coll) # Matrix of derivatives along the orbit D = reshape(u, (coll.ndim, coll.nmesh))*coll.Dt ii = 1:coll.ndim for i in 1:coll.nmesh # Subtract the desired derivative from the actual derivative res[ii] .= D[ii] .- T.*f(u[ii], p, T*(i-1)/coll.nmesh) ii = ii .+ coll.ndim end return res end function example(; nmesh=20) p = (Γ=0.1, ω=1.0, ξ=0.05, ωₙ=1.0, β=0.1) # Do initial value simulation to get a reasonable starting point prob = ODEProblem(duffing, SVector(0.0, 0.0), (0.0, 100*2π/p.ω), p) odesol = solve(prob, Tsit5()) # Refine using collocation t = range(0, 2π/p.ω, length=nmesh+1)[1:end-1] uvec = reinterpret(Float64, odesol(99*2π/p.ω .+ t).u) umat = reshape(uvec, (:, nmesh)) coll = collocation_setup(umat) nlsol1 = nlsolve((res, u) -\u003e collocation!(res, duffing, u, p, 2π/p.ω, coll), uvec) # Adjust the parameters slightly (actually quite a bit!) and correct p = (Γ=0.1, ω=1.1, ξ=0.05, ωₙ=1.0, β=0.1) nlsol2 = nlsolve((res, u) -\u003e collocation!(res, duffing, u, p, 2π/p.ω, coll), uvec) return (nlsol1, nlsol2) end function plot_example() # Needs `using Plots` or similar nmesh = 20 # The two solutions don't actually have the same period but normalize to [0, 2π] t = linspace(0, 2π, length=nmesh+1)[1:end-1] (sol1, sol2) = example() plot(t, sol1.zero[1:2:end]) plot!(t, sol2.zero[1:2:end]) end If you insist on using Matlab, the translation of the Julia code is below. Note that this uses the fourdif function by Reddy and Weideman to generate the Fourier differentiation matrix. (Also note that this can be put in a single file called fourier_collocation.m.)\nfunction [nlsol1, nlsol2] = fourier_collocation() % FOURIER_COLLOCATION Implement Fourier collocation for an arbitrary autonomous % ODE. Assumes that the equations are non-autonomous or the period is known. % Released under the MIT expat license by David A.W. Barton (david.barton@bristol.ac.uk) 2020 nmesh = 20; p = struct('Gamma', 0.1, 'omega', 1.0, 'xi', 0.05, 'omegan', 1.0, 'beta', 0.1); % Do initial value simulation to get a reasonable starting point sol = ode45(@(t, u)duffing(t, u, p), [0, 100*2*pi/p.omega], [0, 0]); % Refine using collocation t = linspace(0, 2*pi/p.omega, nmesh+1); t = t(1:end-1); umat = deval(sol, 99*2*pi/p.omega + t); uvec = umat(:); coll = collocation_setup(umat); nlsol1 = fsolve(@(u)collocation(@duffing, u, p, 2*pi/p.omega, coll), uvec) % Adjust the parameters slightly (actually quite a bit!) and correct p = struct('Gamma', 0.1, 'omega', 1.1, 'xi', 0.05, 'omegan', 1.0, 'beta', 0.1); nlsol2 = fsolve(@(u)collocation(@duffing, u, p, 2*pi/p.omega, coll), uvec) plot(t, nlsol1(1:2:end), 'b', t, nlsol2(1:2:end), 'r'); end function du = duffing(t, u, p) du = [u(2); p.Gamma*sin(p.omega*t) - 2*p.xi*u(2) - p.omegan^2*u(1) - p.beta*u(1)^3]; end function coll = collocation_setup(u) [~, D] = fourdif(size(u, 2), 1); coll = struct('ndim', size(u, 1), 'nmesh', size(u, 2), 'Dt', -D*2*pi); end function res = collocation(f, u, p, T, coll) % Matrix of derivatives along the orbit res = zeros(size(u)); D = reshape(u, [coll.ndim, coll.nmesh])*coll.Dt; ii = 1:coll.ndim; for i = 1:coll.nmesh % Subtract the desired derivative from the actual derivative res(ii) = D(ii) - T*f(T*(i-1)/coll.nmesh, u(ii), p)'; ii = ii + coll.ndim; end end ","wordCount":"968","inLanguage":"en","datePublished":"2020-05-01T00:00:00Z","dateModified":"2020-05-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://cityinthesky.co.uk/posts/2020/collocation-for-finding-periodic-orbits-of-odes/"},"publisher":{"@type":"Organization","name":"David AW Barton","logo":{"@type":"ImageObject","url":"https://cityinthesky.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cityinthesky.co.uk/ accesskey=h title="David AW Barton (Alt + H)">David AW Barton</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://cityinthesky.co.uk/about-me/ title="About me"><span>About me</span></a></li><li><a href=https://cityinthesky.co.uk/research/ title=Research><span>Research</span></a></li><li><a href=https://cityinthesky.co.uk/opensource/ title="Open source"><span>Open source</span></a></li><li><a href=https://cityinthesky.co.uk/christianity/ title=Christianity><span>Christianity</span></a></li><li><a href=https://cityinthesky.co.uk/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cityinthesky.co.uk/>Home</a>&nbsp;»&nbsp;<a href=https://cityinthesky.co.uk/posts/>Posts</a></div><h1 class=post-title>Collocation for finding periodic orbits of ODEs</h1><div class=post-description>Computing periodic orbits of ordinary differential equations (ODEs) with collocation is a relatively quick and easy thing to do. Here I demonstrate the method using both Julia and MATLAB with Fourier collocation.</div><div class=post-meta><span title='2020-05-01 00:00:00 +0000 UTC'>2020-05-01</span></div></header><div class=post-content><p>Every now and again I&rsquo;m asked how to compute the periodic orbits of ODEs using a boundary value solver. Each time, I go looking for old code that does this and, each time, I can&rsquo;t find it and end up rewriting the collocation code from scratch.</p><p>This time I thought I&rsquo;d put my code here so that I have a better chance of finding it again in the future!</p><p>The basic idea is to use a Fourier differentiation matrix to approximate the derivatives along the orbit and use a nonlinear solver to ensure that those derivatives match the vector field. If you want to know more about these types of spectral methods, take a look at the excellent (and short!) introduction by Trefethen in &ldquo;Spectral Methods in MATLAB&rdquo;, SIAM 2000. If you want more detail then the magnum opus by Boyd <a href=http://www-personal.umich.edu/~jpboyd/BOOK_Spectral2000.html>&ldquo;Chebyshev and Fourier Spectral Methods&rdquo;</a>, Dover 2001 (freely available on his personal website) is also very good.</p><p>Nowadays, my preference is for coding in Julia - it&rsquo;s very clean and flexible. Here is the code (which could be better!).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#75715e># Released under the MIT expat license by David A.W. Barton (david.barton@bristol.ac.uk) 2020</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> StaticArrays
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> NLsolve
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> OrdinaryDiffEq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    duffing(u, p, t)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>The vector field of the forced Duffing equation.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>duffing(u, p, t) <span style=color:#f92672>=</span> SVector(u[<span style=color:#ae81ff>2</span>], p<span style=color:#f92672>.</span>Γ<span style=color:#f92672>*</span>sin(p<span style=color:#f92672>.</span>ω<span style=color:#f92672>*</span>t) <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>p<span style=color:#f92672>.</span>ξ<span style=color:#f92672>*</span>u[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>-</span> p<span style=color:#f92672>.</span>ωₙ<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>u[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> p<span style=color:#f92672>.</span>β<span style=color:#f92672>*</span>u[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>^</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    fourier_diff([T=Float64,] N; order=1)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Create a Fourier differentiation matrix of the specified order with numerical type T on the
</span></span></span><span style=display:flex><span><span style=color:#e6db74>domain `x = LinRange{T}(0, 2π, N+1)[1:end-1]`.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> fourier_diff(T<span style=color:#f92672>::</span><span style=color:#66d9ef>Type</span>{<span style=color:#f92672>&lt;:</span><span style=color:#66d9ef>Number</span>}, N<span style=color:#f92672>::</span><span style=color:#66d9ef>Integer</span>; order<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    D <span style=color:#f92672>=</span> zeros(T, N, N)
</span></span><span style=display:flex><span>    n1 <span style=color:#f92672>=</span> (N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>÷</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    n2 <span style=color:#f92672>=</span> N <span style=color:#f92672>÷</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#66d9ef>LinRange</span>{<span style=color:#66d9ef>T</span>}(<span style=color:#ae81ff>0</span>, π, N<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> order <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>N
</span></span><span style=display:flex><span>            sgn <span style=color:#f92672>=</span> (one(T)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> iseven(i))
</span></span><span style=display:flex><span>            D[i, <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> iseven(N) <span style=color:#f92672>?</span> sgn<span style=color:#f92672>*</span>cot(x[i]) <span style=color:#f92672>:</span> sgn<span style=color:#f92672>*</span>csc(x[i])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elseif</span> order <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        D[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> iseven(N) <span style=color:#f92672>?</span> <span style=color:#f92672>-</span>N<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>one(T)<span style=color:#f92672>/</span><span style=color:#ae81ff>12</span> <span style=color:#f92672>-</span> one(T)<span style=color:#f92672>/</span><span style=color:#ae81ff>6</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span>N<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>one(T)<span style=color:#f92672>/</span><span style=color:#ae81ff>12</span> <span style=color:#f92672>+</span> one(T)<span style=color:#f92672>/</span><span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>N
</span></span><span style=display:flex><span>            sgn <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>(one(T)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> iseven(i))
</span></span><span style=display:flex><span>            D[i, <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> iseven(N) <span style=color:#f92672>?</span> sgn<span style=color:#f92672>*</span>csc(x[i])<span style=color:#f92672>.^</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>:</span> sgn<span style=color:#f92672>*</span>cot(x[i])<span style=color:#f92672>*</span>csc(x[i])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        error(<span style=color:#e6db74>&#34;Not implemented&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>N
</span></span><span style=display:flex><span>        D[<span style=color:#ae81ff>1</span>, j] <span style=color:#f92672>=</span> D[N, j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        D[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>N, j] <span style=color:#f92672>.=</span> D[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> D
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>fourier_diff(N<span style=color:#f92672>::</span><span style=color:#66d9ef>Integer</span>; kwargs<span style=color:#f92672>...</span>) <span style=color:#f92672>=</span> fourier_diff(<span style=color:#66d9ef>Float64</span>, N; kwargs<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    collocation_setup(u)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Return a data structure used internally by the `collocation!` function. `u` should be a
</span></span></span><span style=display:flex><span><span style=color:#e6db74>matrix with states down the columns and time across the rows (used for size/type information
</span></span></span><span style=display:flex><span><span style=color:#e6db74>only).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> collocation_setup(u<span style=color:#f92672>::</span><span style=color:#66d9ef>AbstractMatrix</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (ndim<span style=color:#f92672>=</span>size(u, <span style=color:#ae81ff>1</span>), nmesh<span style=color:#f92672>=</span>size(u, <span style=color:#ae81ff>2</span>), Dt<span style=color:#f92672>=-</span>fourier_diff(eltype(u), size(u, <span style=color:#ae81ff>2</span>))<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>π)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    collocation!(res, f, u, p, T, coll)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Calculate the residual of the collocation equations using a Fourier discretisation. Assumes
</span></span></span><span style=display:flex><span><span style=color:#e6db74>that a phase condition is not required (i.e., the equations are non-autonomous or the period
</span></span></span><span style=display:flex><span><span style=color:#e6db74>is known).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74># Arguments
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- `res`: residual (mutated)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- `f`: vector field function (expected to take the arguments (u, p, t))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- `u`: state variables along the orbit (vector)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- `p`: parameter vector passed to the vector field function
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- `T`: period of oscillation
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- `coll`: the output of `collocation_setup`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74># Returns
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- `res`: residual
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> collocation!(res, f, u, p, T, coll)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Matrix of derivatives along the orbit</span>
</span></span><span style=display:flex><span>    D <span style=color:#f92672>=</span> reshape(u, (coll<span style=color:#f92672>.</span>ndim, coll<span style=color:#f92672>.</span>nmesh))<span style=color:#f92672>*</span>coll<span style=color:#f92672>.</span>Dt
</span></span><span style=display:flex><span>    ii <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>coll<span style=color:#f92672>.</span>ndim
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>coll<span style=color:#f92672>.</span>nmesh
</span></span><span style=display:flex><span>        <span style=color:#75715e># Subtract the desired derivative from the actual derivative</span>
</span></span><span style=display:flex><span>        res[ii] <span style=color:#f92672>.=</span> D[ii] <span style=color:#f92672>.-</span> T<span style=color:#f92672>.*</span>f(u[ii], p, T<span style=color:#f92672>*</span>(i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>/</span>coll<span style=color:#f92672>.</span>nmesh)
</span></span><span style=display:flex><span>        ii <span style=color:#f92672>=</span> ii <span style=color:#f92672>.+</span> coll<span style=color:#f92672>.</span>ndim
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> example(; nmesh<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> (Γ<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>, ω<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span>, ξ<span style=color:#f92672>=</span><span style=color:#ae81ff>0.05</span>, ωₙ<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span>, β<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Do initial value simulation to get a reasonable starting point</span>
</span></span><span style=display:flex><span>    prob <span style=color:#f92672>=</span> ODEProblem(duffing, SVector(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>), (<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>π<span style=color:#f92672>/</span>p<span style=color:#f92672>.</span>ω), p)
</span></span><span style=display:flex><span>    odesol <span style=color:#f92672>=</span> solve(prob, Tsit5())
</span></span><span style=display:flex><span>    <span style=color:#75715e># Refine using collocation</span>
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>π<span style=color:#f92672>/</span>p<span style=color:#f92672>.</span>ω, length<span style=color:#f92672>=</span>nmesh<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#66d9ef>end</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    uvec <span style=color:#f92672>=</span> reinterpret(<span style=color:#66d9ef>Float64</span>, odesol(<span style=color:#ae81ff>99</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>π<span style=color:#f92672>/</span>p<span style=color:#f92672>.</span>ω <span style=color:#f92672>.+</span> t)<span style=color:#f92672>.</span>u)
</span></span><span style=display:flex><span>    umat <span style=color:#f92672>=</span> reshape(uvec, (<span style=color:#f92672>:</span>, nmesh))
</span></span><span style=display:flex><span>    coll <span style=color:#f92672>=</span> collocation_setup(umat)
</span></span><span style=display:flex><span>    nlsol1 <span style=color:#f92672>=</span> nlsolve((res, u) <span style=color:#f92672>-&gt;</span> collocation!(res, duffing, u, p, <span style=color:#ae81ff>2</span>π<span style=color:#f92672>/</span>p<span style=color:#f92672>.</span>ω, coll), uvec)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Adjust the parameters slightly (actually quite a bit!) and correct</span>
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> (Γ<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>, ω<span style=color:#f92672>=</span><span style=color:#ae81ff>1.1</span>, ξ<span style=color:#f92672>=</span><span style=color:#ae81ff>0.05</span>, ωₙ<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span>, β<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>    nlsol2 <span style=color:#f92672>=</span> nlsolve((res, u) <span style=color:#f92672>-&gt;</span> collocation!(res, duffing, u, p, <span style=color:#ae81ff>2</span>π<span style=color:#f92672>/</span>p<span style=color:#f92672>.</span>ω, coll), uvec)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (nlsol1, nlsol2)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> plot_example()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Needs `using Plots` or similar</span>
</span></span><span style=display:flex><span>    nmesh <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># The two solutions don&#39;t actually have the same period but normalize to [0, 2π]</span>
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> linspace(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>π, length<span style=color:#f92672>=</span>nmesh<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#66d9ef>end</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    (sol1, sol2) <span style=color:#f92672>=</span> example()
</span></span><span style=display:flex><span>    plot(t, sol1<span style=color:#f92672>.</span>zero[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#66d9ef>end</span>])
</span></span><span style=display:flex><span>    plot!(t, sol2<span style=color:#f92672>.</span>zero[<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#66d9ef>end</span>])
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>If you insist on using Matlab, the translation of the Julia code is below. Note that this uses the <a href=https://www.math.purdue.edu/~shen7/sp_cfd/programs/dmsuite_matlab/fourdif.m><code>fourdif</code> function</a> by Reddy and Weideman to generate the Fourier differentiation matrix. (Also note that this can be put in a single file called <code>fourier_collocation.m</code>.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-matlab data-lang=matlab><span style=display:flex><span><span style=color:#66d9ef>function</span> [nlsol1, nlsol2] = <span style=color:#a6e22e>fourier_collocation</span>()
</span></span><span style=display:flex><span><span style=color:#75715e>% FOURIER_COLLOCATION Implement Fourier collocation for an arbitrary autonomous</span>
</span></span><span style=display:flex><span><span style=color:#75715e>% ODE. Assumes that the equations are non-autonomous or the period is known.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>% Released under the MIT expat license by David A.W. Barton (david.barton@bristol.ac.uk) 2020</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nmesh = <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>p = struct(<span style=color:#e6db74>&#39;Gamma&#39;</span>, <span style=color:#ae81ff>0.1</span>, <span style=color:#e6db74>&#39;omega&#39;</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#e6db74>&#39;xi&#39;</span>, <span style=color:#ae81ff>0.05</span>, <span style=color:#e6db74>&#39;omegan&#39;</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#e6db74>&#39;beta&#39;</span>, <span style=color:#ae81ff>0.1</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>% Do initial value simulation to get a reasonable starting point</span>
</span></span><span style=display:flex><span>sol = ode45(@(t, u)duffing(t, u, p), [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pi<span style=color:#f92672>/</span>p.omega], [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span><span style=color:#75715e>% Refine using collocation</span>
</span></span><span style=display:flex><span>t = linspace(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pi<span style=color:#f92672>/</span>p.omega, nmesh<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>t = t(<span style=color:#ae81ff>1</span>:<span style=color:#66d9ef>end</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>umat = deval(sol, <span style=color:#ae81ff>99</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pi<span style=color:#f92672>/</span>p.omega <span style=color:#f92672>+</span> t);
</span></span><span style=display:flex><span>uvec = umat(:);
</span></span><span style=display:flex><span>coll = collocation_setup(umat);
</span></span><span style=display:flex><span>nlsol1 = fsolve(@(u)collocation(@duffing, u, p, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pi<span style=color:#f92672>/</span>p.omega, coll), uvec)
</span></span><span style=display:flex><span><span style=color:#75715e>% Adjust the parameters slightly (actually quite a bit!) and correct</span>
</span></span><span style=display:flex><span>p = struct(<span style=color:#e6db74>&#39;Gamma&#39;</span>, <span style=color:#ae81ff>0.1</span>, <span style=color:#e6db74>&#39;omega&#39;</span>, <span style=color:#ae81ff>1.1</span>, <span style=color:#e6db74>&#39;xi&#39;</span>, <span style=color:#ae81ff>0.05</span>, <span style=color:#e6db74>&#39;omegan&#39;</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#e6db74>&#39;beta&#39;</span>, <span style=color:#ae81ff>0.1</span>);
</span></span><span style=display:flex><span>nlsol2 = fsolve(@(u)collocation(@duffing, u, p, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pi<span style=color:#f92672>/</span>p.omega, coll), uvec)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plot(t, nlsol1(<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>2</span>:<span style=color:#66d9ef>end</span>), <span style=color:#e6db74>&#39;b&#39;</span>, t, nlsol2(<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>2</span>:<span style=color:#66d9ef>end</span>), <span style=color:#e6db74>&#39;r&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> du = <span style=color:#a6e22e>duffing</span>(t, u, p)
</span></span><span style=display:flex><span>    du = [u(<span style=color:#ae81ff>2</span>); p.Gamma<span style=color:#f92672>*</span>sin(p.omega<span style=color:#f92672>*</span>t) <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>p.xi<span style=color:#f92672>*</span>u(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>-</span> p.omegan^<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>u(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>-</span> p.beta<span style=color:#f92672>*</span>u(<span style=color:#ae81ff>1</span>)^<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> coll = <span style=color:#a6e22e>collocation_setup</span>(u)
</span></span><span style=display:flex><span>    [<span style=color:#f92672>~</span>, D] = fourdif(size(u, <span style=color:#ae81ff>2</span>), <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    coll = struct(<span style=color:#e6db74>&#39;ndim&#39;</span>, size(u, <span style=color:#ae81ff>1</span>), <span style=color:#e6db74>&#39;nmesh&#39;</span>, size(u, <span style=color:#ae81ff>2</span>), <span style=color:#e6db74>&#39;Dt&#39;</span>, <span style=color:#f92672>-</span>D<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pi);
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> res = <span style=color:#a6e22e>collocation</span>(f, u, p, T, coll)
</span></span><span style=display:flex><span>    <span style=color:#75715e>% Matrix of derivatives along the orbit</span>
</span></span><span style=display:flex><span>    res = zeros(size(u));
</span></span><span style=display:flex><span>    D = reshape(u, [coll.ndim, coll.nmesh])<span style=color:#f92672>*</span>coll.Dt;
</span></span><span style=display:flex><span>    ii = <span style=color:#ae81ff>1</span>:coll.ndim;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i = <span style=color:#ae81ff>1</span>:coll.nmesh
</span></span><span style=display:flex><span>        <span style=color:#75715e>% Subtract the desired derivative from the actual derivative</span>
</span></span><span style=display:flex><span>        res(ii) = D(ii) <span style=color:#f92672>-</span> T<span style=color:#f92672>*</span>f(T<span style=color:#f92672>*</span>(i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>/</span>coll.nmesh, u(ii), p)<span style=color:#f92672>&#39;</span>;
</span></span><span style=display:flex><span>        ii = ii <span style=color:#f92672>+</span> coll.ndim;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://cityinthesky.co.uk/tags/julia/>julia</a></li><li><a href=https://cityinthesky.co.uk/tags/mathematics/>mathematics</a></li></ul><nav class=paginav><a class=prev href=https://cityinthesky.co.uk/posts/2021/broad-project-areas/><span class=title>« Prev</span><br><span>Broad areas for potential projects</span></a>
<a class=next href=https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/><span class=title>Next »</span><br><span>Working with broadcasting in Julia</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://cityinthesky.co.uk/>David AW Barton</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>