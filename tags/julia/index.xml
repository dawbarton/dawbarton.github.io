<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Julia on David A W Barton</title><link>https://cityinthesky.co.uk/tags/julia/</link><description>Recent content in Julia on David A W Barton</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 30 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cityinthesky.co.uk/tags/julia/index.xml" rel="self" type="application/rss+xml"/><item><title>Stability of delay differential equations (DDEs) in Julia</title><link>https://cityinthesky.co.uk/posts/2021/stability-of-delay-differential-equations-in-julia/</link><pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate><guid>https://cityinthesky.co.uk/posts/2021/stability-of-delay-differential-equations-in-julia/</guid><description>Another in my series of &amp;#39;try not to implement it yet again&amp;#39;, this time on how to calculate the stability of (linearised) delay differential equations.</description></item><item><title>Collocation for finding periodic orbits of ODEs</title><link>https://cityinthesky.co.uk/posts/2020/collocation-for-finding-periodic-orbits-of-odes/</link><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate><guid>https://cityinthesky.co.uk/posts/2020/collocation-for-finding-periodic-orbits-of-odes/</guid><description>Computing periodic orbits of ordinary differential equations (ODEs) with collocation is a relatively quick and easy thing to do. Here I demonstrate the method using both Julia and MATLAB with Fourier collocation.</description></item><item><title>Working with broadcasting in Julia</title><link>https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/</link><pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate><guid>https://cityinthesky.co.uk/posts/2019/working-with-broadcasting-in-julia/</guid><description>&lt;p>Broadcasting in Julia is a way of writing vectorised code (think Matlab) that is performant and explicit. The benefits of performant code are obvious (faster!) but explicit vectorisation is also a significant benefit.&lt;/p>
&lt;p>When I first saw Matlab and how you could call the &lt;code>sin&lt;/code> with a vector input, I was (slightly) blown away by the usefulness of this. It didn&amp;rsquo;t take too long for me to realise the limitations though; vectorising a complicated function can require quite a bit of code gymnastics, which doesn&amp;rsquo;t usually help the readability, particularly for those students who are relatively new to programming.&lt;/p></description></item><item><title>BarycentricInterpolation.jl</title><link>https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/</link><pubDate>Tue, 04 Dec 2018 00:00:00 +0000</pubDate><guid>https://cityinthesky.co.uk/posts/2018/barycentricinterpolation.jl/</guid><description>&lt;p>Over the past couple of years or so I&amp;rsquo;ve been getting into the Julia programming language; it&amp;rsquo;s been great to watch the language mature over time. Many people proclaim the virtues of its speed (it&amp;rsquo;s very fast for a dynamic language) but really I like its elegance - it&amp;rsquo;s a very well designed language that makes full use of multiple dispatch. (Multiple dispatch is something that I doubt most coders know much about but once you are used to it, it&amp;rsquo;s indispensable!)&lt;/p></description></item></channel></rss>